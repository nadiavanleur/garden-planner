<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Garden Planner</title>
  <style>
    :root {
      --cm: 5px;
    }

    body {
      font-family: sans-serif;
      padding: 1rem;
      background: #f0f9f0;
    }

    .toolbar {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }

    .toolbar button {
      padding: 0.5rem;
    }

    .garden {
      position: relative;
      width: 100%;
      height: 600px;
      background-color: #c8e0c8;
      background-image:
        linear-gradient(#d2e8d2 1px, transparent 1px), linear-gradient(90deg, #d2e8d2 1px, transparent 1px);
      background-size: calc(10 * var(--cm)) calc(10 * var(--cm));
      border: 2px solid #444;
      overflow: auto;
    }

    .bed {
      position: absolute;
      background: #fff7e6;
      border: 4px solid #8b5a2b;
      box-shadow: inset 0 0 5px #ccc;
      resize: both;
      overflow: hidden;
    }

    .bed .drag-handle {
      background: #8b5a2b;
      color: white;
      padding: 4px;
      cursor: move;
      font-size: 0.75rem;
      text-align: center;
      user-select: none;
      display: none;
    }

    .bed:hover .drag-handle {
      display: block;
    }

    .bed .size-label {
      position: absolute;
      bottom: 2px;
      right: 4px;
      background: rgba(255, 255, 255, 0.8);
      font-size: 0.7rem;
      padding: 2px 4px;
      border-radius: 3px;
      pointer-events: none;
      display: none;
    }

    .bed:hover .size-label {
      display: block;
    }

    .bed .delete-btn,
    .bed .duplicate-btn {
      position: absolute;
      top: 2px;
      background: rgba(255, 80, 80, 0.8);
      border: none;
      color: white;
      font-size: 0.8rem;
      border-radius: 50%;
      width: 18px;
      height: 18px;
      display: none;
      cursor: pointer;
      z-index: 10;
    }

    .bed .delete-btn {
      right: 0;
    }

    .bed .duplicate-btn {
      right: 24px;
      background: rgba(80, 80, 255, 0.8);
    }

    .bed:hover .delete-btn,
    .bed:hover .duplicate-btn {
      display: block;
    }

    .plant {
      text-align: center;
      position: absolute;
      width: calc(10 * var(--cm));
      height: calc(10 * var(--cm));
      cursor: grab;
      transform: translate(-50%, -50%);
    }

    .plant span {
      display: block;
      font-size: 2rem;
      text-align: center;
      user-select: none;
    }

    .plant .plant-name {
      font-size: 0.8rem;
      color: #555;
      text-align: center;
      user-select: none;
    }

    .plant .sowing-date {
      font-size: 0.7rem;
      color: #555;
      text-align: center;
      margin-top: 4px;
    }

    .plant .delete-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      background: rgba(255, 80, 80, 0.8);
      border: none;
      color: white;
      font-size: 0.8rem;
      border-radius: 50%;
      width: 18px;
      height: 18px;
      display: none;
      cursor: pointer;
      z-index: 10;
    }

    .plant:hover .delete-btn {
      display: block;
    }
  </style>
</head>

<body>

  <h1>ðŸŒ¿ Garden Planner</h1>
  <div class="toolbar"></div>

  <div class="garden" id="garden"></div>

  <script>
    const plantEmojis = {
      Arugula: "ðŸ¥—", // Rucola
      Marjoram: "ðŸŒ¿",
      "Curly Parsley": "ðŸŒ±",
      "Flat Parsley": "ðŸ¥¬",
      Lavender: "ðŸ’œ",
      "Winter Thyme": "ðŸŒ¿",
      Sage: "ðŸƒ",
      "St. John's Wort": "ðŸŒ¼",
      Valerian: "ðŸŒ¸",
      Dill: "ðŸŒ¿",
      Tomato: "ðŸ…",
      Strawberry: "ðŸ“",
      "Spring Onion": "ðŸ§…",
      Onion: "ðŸ§…",
      Thyme: "ðŸŒ¿", // Regular Thyme
    };

    const garden = document.getElementById("garden");
    let selectedPlant = null;

    function getPixelsPerCm() {
      console.log("getPixelsPerCm called");
      const input = document.getElementById("pixelsPerCm");
      return Math.max(1, parseInt(input.value) || 5); // Ensure a valid value
    }

    function updatePixelsPerCm() {
      console.log("updatePixelsPerCm called");
      const input = document.getElementById("pixelsPerCm");
      const oldPixelsPerCm = parseFloat(input.dataset.oldValue) || getPixelsPerCm();
      const newPixelsPerCm = getPixelsPerCm();

      // Update the CSS variable for the grid size
      document.documentElement.style.setProperty("--cm", `${newPixelsPerCm}px`);

      // Scale all beds and plants based on the new pixelsPerCm value
      const scaleFactor = newPixelsPerCm / oldPixelsPerCm;

      document.querySelectorAll(".bed").forEach((bed) => {
        const width = parseFloat(bed.style.width) * scaleFactor;
        const height = parseFloat(bed.style.height) * scaleFactor;
        const left = parseFloat(bed.style.left) * scaleFactor;
        const top = parseFloat(bed.style.top) * scaleFactor;

        bed.style.width = `${width}px`;
        bed.style.height = `${height}px`;
        bed.style.left = `${left}px`;
        bed.style.top = `${top}px`;

        // Update plants inside the bed
        bed.querySelectorAll(".plant").forEach((plant) => {
          const plantLeft = parseFloat(plant.style.left) * scaleFactor;
          const plantTop = parseFloat(plant.style.top) * scaleFactor;

          plant.style.left = `${plantLeft}px`;
          plant.style.top = `${plantTop}px`;
        });
      });

      input.dataset.oldValue = newPixelsPerCm; // Store the new value for future scaling
      updateGardenSize(); // Recalculate garden size
    }

    function deselectPlant() {
      console.log("deselectPlant called");
      selectedPlant = null;
      const dropdown = document.getElementById("plantSelector");
      if (dropdown) dropdown.value = ""; // Reset dropdown selection
    }

    function selectPlant(name) {
      selectedPlant = name;
      const dropdown = document.getElementById("plantSelector");
      if (dropdown) dropdown.value = name; // Update dropdown selection
    }

    function updateGardenSize() {
      console.log("updateGardenSize called");
      deselectPlant(); // Deselect plant when updating garden size

      const beds = document.querySelectorAll(".bed");
      let maxRight = 0;
      let maxBottom = 0;

      beds.forEach((bed) => {
        const rect = bed.getBoundingClientRect();
        const gardenRect = garden.getBoundingClientRect();
        const right = rect.left - gardenRect.left + bed.offsetWidth;
        const bottom = rect.top - gardenRect.top + bed.offsetHeight;

        if (right > maxRight) maxRight = right;
        if (bottom > maxBottom) maxBottom = bottom;
      });

      garden.style.minWidth = `${maxRight}px`;
      garden.style.minHeight = `${maxBottom}px`;
    }

    function addBed(existingBed = null) {
      console.log("addBed called");
      const borderWidth = 8; // Total border width (4px on each side)

      const bed = document.createElement("div");
      bed.className = "bed";

      let left, top, totalWidth, totalHeight;

      if (existingBed) {
        // Duplicate properties from the existing bed
        totalWidth = parseInt(existingBed.style.width) + borderWidth;
        totalHeight = parseInt(existingBed.style.height) + borderWidth;
        totalWidth = snapToGrid(totalWidth); // Snap total width
        totalHeight = snapToGrid(totalHeight); // Snap total height
        bed.style.width = `${totalWidth - borderWidth}px`; // Subtract border width
        bed.style.height = `${totalHeight - borderWidth}px`; // Subtract border width
        left = parseInt(existingBed.style.left) + 20; // Initial offset position
        top = parseInt(existingBed.style.top) + 20;
      } else {
        totalWidth = snapToGrid(getPixelsPerCm() * 60 + borderWidth); // Include border in size
        totalHeight = snapToGrid(getPixelsPerCm() * 60 + borderWidth); // Include border in size
        bed.style.width = `${totalWidth - borderWidth}px`; // Subtract border width
        bed.style.height = `${totalHeight - borderWidth}px`; // Subtract border width
        left = 50;
        top = 50;

        // Temporarily append the bed to check for overlaps
        garden.appendChild(bed);
        while (checkOverlap(bed, left, top)) {
          left += 20; // Increment position to avoid overlap
          if (left + totalWidth > garden.offsetWidth) { // Wrap to the next row if out of bounds
            left = 50;
            top += 20;
          }
          if (top + totalHeight > garden.offsetHeight) { // Prevent going out of garden bounds
            garden.removeChild(bed);
            alert("No space available to add a new bed.");
            return;
          }
        }
        garden.removeChild(bed); // Remove the temporary bed
      }

      bed.style.left = `${left}px`;
      bed.style.top = `${top}px`;

      const handle = document.createElement("div");
      handle.className = "drag-handle";
      handle.textContent = "ðŸŒ± Drag Me";

      const label = document.createElement("div");
      label.className = "size-label";
      label.textContent = `${Math.round(totalWidth / getPixelsPerCm())} x ${Math.round(totalHeight / getPixelsPerCm())} cm`;

      const deleteBtn = document.createElement("button");
      deleteBtn.className = "delete-btn";
      deleteBtn.textContent = "ðŸ—‘ï¸";
      deleteBtn.onclick = () => {
        bed.remove();
        updateGardenSize(); // Update garden size after removing a bed
      };

      const duplicateBtn = document.createElement("button");
      duplicateBtn.className = "duplicate-btn";
      duplicateBtn.textContent = "ðŸ“‹";
      duplicateBtn.onclick = () => addBed(bed);

      let isDragging = false;
      let dragOffsetX = 0;
      let dragOffsetY = 0;

      handle.addEventListener("mousedown", (e) => {
        isDragging = true;
        dragOffsetX = e.offsetX;
        dragOffsetY = e.offsetY;
        e.stopPropagation();
      });

      document.addEventListener("mouseup", () => isDragging = false);

      document.addEventListener("mousemove", (e) => {
        if (isDragging) {
          const newLeft = Math.max(0, snapToGrid(e.pageX - garden.offsetLeft - dragOffsetX)); // Prevent going off the left
          const newTop = Math.max(0, snapToGrid(e.pageY - garden.offsetTop - dragOffsetY)); // Prevent going off the top
          if (!checkOverlap(bed, newLeft, newTop)) {
            bed.style.left = `${newLeft}px`;
            bed.style.top = `${newTop}px`;
            updateGardenSize(); // Update garden size after moving a bed
          }
        }
      });

      // Click to add plant
      bed.addEventListener("click", (e) => {
        if (!selectedPlant || e.target.closest(".plant") || e.target.classList.contains("drag-handle")) return;
        const rect = bed.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const plant = createPlantElement(selectedPlant, x, y);
        bed.appendChild(plant);
      });

      // Resize snap & label
      let isResizing = false;

      const resizeObserver = new ResizeObserver(() => {
        isResizing = true
        let w = parseInt(bed.style.width) + borderWidth;
        let h = parseInt(bed.style.height) + borderWidth;
        w = snapToGrid(w); // Ensure total width snaps correctly
        h = snapToGrid(h); // Ensure total height snaps correctly
        if (!checkOverlap(bed, parseInt(bed.style.left), parseInt(bed.style.top), w, h)) {
          bed.style.width = `${w - borderWidth}px`; // Subtract border width
          bed.style.height = `${h - borderWidth}px`; // Subtract border width
          label.textContent = `${Math.round(w / getPixelsPerCm())} x ${Math.round(h / getPixelsPerCm())} cm`;
          updateGardenSize(); // Update garden size after resizing
        }
      });

      document.addEventListener("mouseup", () => {
        if (isResizing) {
          let w = parseInt(bed.style.width) + borderWidth;
          let h = parseInt(bed.style.height) + borderWidth;
          w = snapToGrid(w); // Final snap after resizing
          h = snapToGrid(h); // Final snap after resizing
          if (!checkOverlap(bed, parseInt(bed.style.left), parseInt(bed.style.top), w, h)) {
            bed.style.width = `${w - borderWidth}px`; // Subtract border width
            bed.style.height = `${h - borderWidth}px`; // Subtract border width
            label.textContent = `${Math.round(w / getPixelsPerCm())} x ${Math.round(h / getPixelsPerCm())} cm`;
            updateGardenSize(); // Update garden size after resizing
          }
          isResizing = false;
        }
      });

      resizeObserver.observe(bed);

      // Append the bed after finding a valid position
      garden.appendChild(bed);
      bed.appendChild(deleteBtn);
      bed.appendChild(duplicateBtn);
      bed.appendChild(handle);
      bed.appendChild(label);

      updateGardenSize(); // Ensure garden size is updated after adding a bed
    }

    function checkOverlap(currentBed, newLeft, newTop, newWidth = null, newHeight = null) {
      console.log("checkOverlap called");
      const beds = document.querySelectorAll(".bed");
      const currentRect = {
        left: newLeft,
        top: newTop,
        right: newLeft + (newWidth || currentBed.offsetWidth),
        bottom: newTop + (newHeight || currentBed.offsetHeight),
      };

      for (const bed of beds) {
        if (bed === currentBed) continue;
        const rect = bed.getBoundingClientRect();
        const gardenRect = garden.getBoundingClientRect();
        const bedRect = {
          left: rect.left - gardenRect.left,
          top: rect.top - gardenRect.top,
          right: rect.left - gardenRect.left + bed.offsetWidth,
          bottom: rect.top - gardenRect.top + bed.offsetHeight,
        };

        if (
          currentRect.left < bedRect.right &&
          currentRect.right > bedRect.left &&
          currentRect.top < bedRect.bottom &&
          currentRect.bottom > bedRect.top &&
          !(currentRect.right === bedRect.left || currentRect.left === bedRect.right || currentRect.bottom === bedRect.top || currentRect.top === bedRect.bottom)
        ) {
          return true; // Overlap detected
        }
      }
      return false; // No overlap
    }

    function createPlantElement(name, x, y) {
      console.log("createPlantElement called");
      const div = document.createElement("div");
      div.className = "plant";
      div.style.left = `${x}px`;
      div.style.top = `${y}px`;

      const emoji = document.createElement("span");
      emoji.textContent = plantEmojis[name] || "ðŸŒ±";
      emoji.title = name;
      div.appendChild(emoji);

      const plantName = document.createElement("div");
      plantName.className = "plant-name";
      plantName.textContent = name;
      div.appendChild(plantName);

      const sowingDateLabel = document.createElement("div");
      sowingDateLabel.className = "sowing-date";
      sowingDateLabel.textContent = "Sowing Date: Not Set";
      div.appendChild(sowingDateLabel);

      const sowingDateInput = document.createElement("input");
      sowingDateInput.type = "date";
      sowingDateInput.onchange = () => {
        sowingDateLabel.textContent = `Sowing Date: ${sowingDateInput.value}`;
      };
      div.appendChild(sowingDateInput);

      const deleteBtn = document.createElement("button");
      deleteBtn.className = "delete-btn";
      deleteBtn.textContent = "ðŸ—‘ï¸";
      deleteBtn.onclick = () => div.remove();
      div.appendChild(deleteBtn);

      let dragging = false;
      let offsetX = 0;
      let offsetY = 0;

      div.addEventListener("mousedown", (e) => {
        dragging = true;
        offsetX = e.offsetX;
        offsetY = e.offsetY;
        e.stopPropagation();
      });

      document.addEventListener("mouseup", () => dragging = false);

      document.addEventListener("mousemove", (e) => {
        if (dragging) {
          const bed = div.parentElement;
          const rect = bed.getBoundingClientRect();
          div.style.left = `${e.clientX - rect.left - offsetX}px`;
          div.style.top = `${e.clientY - rect.top - offsetY}px`;
        }
      });

      return div;
    }

    function snapToGrid(val) {
      console.log("snapToGrid called");
      const pixelsPer10Cm = getPixelsPerCm() * 10; // 10cm grid
      return Math.round(val / pixelsPer10Cm) * pixelsPer10Cm;
    }

    function saveData() {
      const data = {
        pixelsPerCm: getPixelsPerCm(),
        beds: [],
      };

      document.querySelectorAll(".bed").forEach((bed) => {
        const bedData = {
          left: parseFloat(bed.style.left),
          top: parseFloat(bed.style.top),
          width: parseFloat(bed.style.width),
          height: parseFloat(bed.style.height),
          plants: [],
        };

        bed.querySelectorAll(".plant").forEach((plant) => {
          const plantData = {
            name: plant.querySelector(".plant-name").textContent,
            left: parseFloat(plant.style.left),
            top: parseFloat(plant.style.top),
            sowingDate: plant.querySelector("input[type='date']").value || null,
          };
          bedData.plants.push(plantData);
        });

        data.beds.push(bedData);
      });

      localStorage.setItem("gardenData", JSON.stringify(data));
      alert("Garden data saved!");
    }

    function loadData() {
      const data = JSON.parse(localStorage.getItem("gardenData"));
      if (!data) return;

      garden.innerHTML = "";

      if (data.pixelsPerCm) {
        const input = document.getElementById("pixelsPerCm");
        input.value = data.pixelsPerCm;
        input.dataset.oldValue = data.pixelsPerCm;
        updatePixelsPerCm();
      }

      data.beds.forEach((bedData) => {
        const bed = document.createElement("div");
        bed.className = "bed";
        bed.style.left = `${bedData.left}px`;
        bed.style.top = `${bedData.top}px`;
        bed.style.width = `${bedData.width}px`;
        bed.style.height = `${bedData.height}px`;

        bedData.plants.forEach((plantData) => {
          const plant = createPlantElement(plantData.name, plantData.left, plantData.top);
          if (plantData.sowingDate) {
            const sowingDateInput = plant.querySelector("input[type='date']");
            const sowingDateLabel = plant.querySelector(".sowing-date");
            sowingDateInput.value = plantData.sowingDate;
            sowingDateLabel.textContent = `Sowing Date: ${plantData.sowingDate}`;
          }
          bed.appendChild(plant);
        });

        garden.appendChild(bed);
        addBedEventListeners(bed);
      });
    }

    function addBedEventListeners(bed) {
      const borderWidth = 8; // Total border width (4px on each side)

      const totalWidth = parseInt(bed.style.width) + borderWidth;
      const totalHeight = parseInt(bed.style.height) + borderWidth;

      const handle = document.createElement("div");
      handle.className = "drag-handle";
      handle.textContent = "ðŸŒ± Drag Me";

      const label = document.createElement("div");
      label.className = "size-label";
      label.textContent = `${Math.round(totalWidth / getPixelsPerCm())} x ${Math.round(totalHeight / getPixelsPerCm())} cm`;

      const deleteBtn = document.createElement("button");
      deleteBtn.className = "delete-btn";
      deleteBtn.textContent = "ðŸ—‘ï¸";
      deleteBtn.onclick = () => {
        bed.remove();
        updateGardenSize(); // Update garden size after removing a bed
      };

      const duplicateBtn = document.createElement("button");
      duplicateBtn.className = "duplicate-btn";
      duplicateBtn.textContent = "ðŸ“‹";
      duplicateBtn.onclick = () => addBed(bed);

      let isDragging = false;
      let dragOffsetX = 0;
      let dragOffsetY = 0;

      handle.addEventListener("mousedown", (e) => {
        isDragging = true;
        dragOffsetX = e.offsetX;
        dragOffsetY = e.offsetY;
        e.stopPropagation();
      });

      document.addEventListener("mouseup", () => isDragging = false);

      document.addEventListener("mousemove", (e) => {
        if (isDragging) {
          const newLeft = Math.max(0, snapToGrid(e.pageX - garden.offsetLeft - dragOffsetX)); // Prevent going off the left
          const newTop = Math.max(0, snapToGrid(e.pageY - garden.offsetTop - dragOffsetY)); // Prevent going off the top
          if (!checkOverlap(bed, newLeft, newTop)) {
            bed.style.left = `${newLeft}px`;
            bed.style.top = `${newTop}px`;
            updateGardenSize(); // Update garden size after moving a bed
          }
        }
      });

      // Click to add plant
      bed.addEventListener("click", (e) => {
        if (!selectedPlant || e.target.closest(".plant") || e.target.classList.contains("drag-handle")) return;
        const rect = bed.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const plant = createPlantElement(selectedPlant, x, y);
        bed.appendChild(plant);
      });

      // Resize snap & label
      let isResizing = false;

      const resizeObserver = new ResizeObserver(() => {
        isResizing = true
        let w = parseInt(bed.style.width) + borderWidth;
        let h = parseInt(bed.style.height) + borderWidth;
        w = snapToGrid(w); // Ensure total width snaps correctly
        h = snapToGrid(h); // Ensure total height snaps correctly
        if (!checkOverlap(bed, parseInt(bed.style.left), parseInt(bed.style.top), w, h)) {
          bed.style.width = `${w - borderWidth}px`; // Subtract border width
          bed.style.height = `${h - borderWidth}px`; // Subtract border width
          label.textContent = `${Math.round(w / getPixelsPerCm())} x ${Math.round(h / getPixelsPerCm())} cm`;
          updateGardenSize(); // Update garden size after resizing
        }
      });

      document.addEventListener("mouseup", () => {
        if (isResizing) {
          let w = parseInt(bed.style.width) + borderWidth;
          let h = parseInt(bed.style.height) + borderWidth;
          w = snapToGrid(w); // Final snap after resizing
          h = snapToGrid(h); // Final snap after resizing
          if (!checkOverlap(bed, parseInt(bed.style.left), parseInt(bed.style.top), w, h)) {
            bed.style.width = `${w - borderWidth}px`; // Subtract border width
            bed.style.height = `${h - borderWidth}px`; // Subtract border width
            label.textContent = `${Math.round(w / getPixelsPerCm())} x ${Math.round(h / getPixelsPerCm())} cm`;
            updateGardenSize(); // Update garden size after resizing
          }
          isResizing = false;
        }
      });

      resizeObserver.observe(bed);

      // Append the bed after finding a valid position
      garden.appendChild(bed);
      bed.appendChild(deleteBtn);
      bed.appendChild(duplicateBtn);
      bed.appendChild(handle);
      bed.appendChild(label);
    }

    // Update toolbar buttons
    const toolbar = document.querySelector(".toolbar");
    toolbar.innerHTML = `
      <button onclick="addBed()">âž• Add Garden Bed</button>
      <label>
        <span>Pick a Plant:</span>
        <select id="plantSelector" onchange="selectPlant(this.value)">
          <option value="">-- Select a Plant --</option>
          ${Object.keys(plantEmojis).map(plant => `<option value="${plant}">${plant}</option>`).join('')}
        </select>
      </label>
      <label>
        <span>Pixels per 1cm:</span>
        <input type="number" id="pixelsPerCm" value="5" min="1" onchange="updatePixelsPerCm()" />
      </label>
    `;

    // Add Save and Load buttons to the toolbar
    const saveButton = document.createElement("button");
    saveButton.textContent = "ðŸ’¾ Save Garden";
    saveButton.onclick = saveData;
    toolbar.appendChild(saveButton);

    const loadButton = document.createElement("button");
    loadButton.textContent = "ðŸ“‚ Load Garden";
    loadButton.onclick = loadData;
    toolbar.appendChild(loadButton);

    // Load data on page load
    window.onload = loadData;
  </script>

</body>

</html>